#include "Base/TypeSystem/TypeRegistry.h"
#include "Base/Application/ApplicationGlobalState.h"
#include "Base/FileSystem/FileSystem.h"
#include "Base/Serialization/BinarySerialization.h"
#include "Base/Math/NumericRange.h"
#include "Base/Types/Event.h"

#include "_AutoGenerated/ToolsTypeRegistration.h"

#include <iostream>
#include "Base/Network/IPC/IPCMessage.h"
#include "Base/Math/MathRandom.h"
#include "Base/Time/Timers.h"
#include "Base/Encoding/Quantization.h"
#include "Base/Types/RefCounting.h"

//-------------------------------------------------------------------------

using namespace EE;

//-------------------------------------------------------------------------

class ObjectDestroyer;

struct MyRefObjectA : public ThreadSafeRcObject
{
    MyRefObjectA( int a )
        : m_a( a )
    {
    }

    virtual ~MyRefObjectA();

    void Log() const { std::cout << m_a << "\n"; }

    ObjectDestroyer*            m_pDestroyer = nullptr;
    int                         m_a;
};

class ObjectDestroyer
{
public:

    void Destroy( MyRefObjectA* pObject )
    {
        std::cout << "Kill by ObjectDestroyer.";
        pObject->Log();
    }
};

MyRefObjectA::~MyRefObjectA()
{
    std::cout << "[A] Destruct!\n";
    m_pDestroyer->Destroy( this );
}

struct MyRefObjectB final : public MyRefObjectA
{
    MyRefObjectB( double b )
        : m_b( b ), MyRefObjectA( 4 )
    {
    }
    virtual ~MyRefObjectB() final
    {
        std::cout << "[B] Destruct!\n";
    }

    void Log() const { std::cout << m_b << " " << m_a << "\n"; }

    double                      m_b;
};

//-------------------------------------------------------------------------

EE_FORCE_INLINE float Dot( Float3 const& a, Float3 const& b )
{
    float const d = ( a.m_x * b.m_x ) + ( a.m_y * b.m_y ) + ( a.m_z * b.m_z );
    return d;
}

EE_FORCE_INLINE Float3 Cross3( Float3 const& a, Float3 const& b )
{
    float x = ( a.m_y * b.m_z ) - ( a.m_z * b.m_y );
    float y = ( a.m_z * b.m_x ) - ( a.m_x * b.m_z );
    float z = ( a.m_x * b.m_y ) - ( a.m_y * b.m_x );
    return Float3( x, y, z );
}

EE_FORCE_INLINE Float4 QuatMul( Float4 const &a, Float4 const& b )
{
   return Float4(
            ( b.m_w * a.m_x ) + ( b.m_x * a.m_w ) + ( b.m_y * a.m_z ) - ( b.m_z * a.m_y ),
            ( b.m_w * a.m_y ) - ( b.m_x * a.m_z ) + ( b.m_y * a.m_w ) + ( b.m_z * a.m_x ),
            ( b.m_w * a.m_z ) + ( b.m_x * a.m_y ) - ( b.m_y * a.m_x ) + ( b.m_z * a.m_w ),
            ( b.m_w * a.m_w ) - ( b.m_x * a.m_x ) - ( b.m_y * a.m_y ) - ( b.m_z * a.m_z )
        );
}

//-------------------------------------------------------------------------

class C
{
    int32_t x = 18;
    int32_t y = 18;
    int32_t z = 18;
    int32_t w = 18;
};

template<class M, class Secret>
struct public_cast
{
    static inline M m{};
};

template<class Secret, auto M>
struct access
{
    static const inline auto m = public_cast<decltype(M), Secret>::m = M;
};

//-------------------------------------------------------------------------

template struct access<class CxSecret, &C::x>;
template struct access<class CxSecret, &C::y>;
template struct access<class CxSecret, &C::z>;
template struct access<class CxSecret, &C::w>;

//-------------------------------------------------------------------------

int main( int argc, char *argv[] )
{
    {
        EE::ApplicationGlobalState State;
        TypeSystem::TypeRegistry typeRegistry;
        TypeSystem::Reflection::RegisterTypes( typeRegistry );

        //-------------------------------------------------------------------------
        
        Quaternion q( 0.851569f, -0.522476f, 0.010197f, 0.0417675f );
        Quantization::EncodedQuaternion eq( q );
        Quaternion dq = eq.ToQuaternion();

        //-------------------------------------------------------------------------

        //constexpr static int32_t const size = 10000;

        //Float4 s[size];
        //Float4 sR[size];

        //for ( int32_t i = 0; i < size; i++ )
        //{
        //    s[i] = Float4( Math::GetRandomFloat( -20000, 20000 ), Math::GetRandomFloat( -20000, 20000 ), Math::GetRandomFloat( -20000, 20000 ), Math::GetRandomFloat( -20000, 20000 ) );
        //}

        //Quaternion v[size];
        //Quaternion vR[size];

        //for ( int32_t i = 0; i < size; i++ )
        //{
        //    v[i] = Quaternion( s[i] );
        //}

        ////-------------------------------------------------------------------------

        //Milliseconds time;

        //{
        //    ScopedTimer<PlatformClock> t( time );

        //    for ( int32_t j = 0; j < 100000; j++ )
        //    {
        //        for ( int32_t i = 0; i < ( size - 1 ); i++ )
        //        {
        //            sR[i] = QuatMul( s[i], s[i+1] );
        //        }
        //    }
        //}

        //std::cout << "Scalar: " << time.ToFloat() << "ms" << std::endl;
        //std::cout << sR[340].m_y << std::endl;

        ////-------------------------------------------------------------------------

        //{
        //    ScopedTimer<PlatformClock> t( time );

        //    for ( int32_t j = 0; j < 100000; j++ )
        //    {
        //        for ( int32_t i = 0; i < ( size - 1 ); i++ )
        //        {
        //            vR[i] = v[i] * v[i + 1];
        //        }
        //    }
        //}
        //
        //std::cout << "Vector: " << time.ToFloat() << "ms" << std::endl;

        //-------------------------------------------------------------------------

        ObjectDestroyer destroyer;

        auto refPtrA = RefPtr<MyRefObjectA>::New<MyRefObjectB>( 8.5454 );
        auto refPtrB = RefPtr<MyRefObjectB>::New( 2.33 );

        refPtrA->m_pDestroyer = &destroyer;
        refPtrB->m_pDestroyer = &destroyer;

        std::thread threads[1];

        for ( uint32_t i = 0; i < 1; ++i )
        {
            threads[i] = std::thread( [=] ()
            {
                {
                    RefPtr<MyRefObjectA> innerPtr;
                    innerPtr = refPtrB;
                }

                refPtrA->Log();
                refPtrB->Log();
            } );
        }
        
        for ( uint32_t i = 0; i < 1; ++i )
        {
            threads[i].join();
        }

        //-------------------------------------------------------------------------

        TypeSystem::Reflection::UnregisterTypes( typeRegistry );
    }

    return 0;
}